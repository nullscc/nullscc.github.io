
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  
  <title>cs.CL - 2023-09-10 | Fun Paper</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="The Effect of Alignment Objectives on Code-Switching Translation paper_url: http:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2309.05044 repo_url: None paper_authors: Mohamed Anwar for: 这个论文主要是为了提高机器翻译模型对Code-switching内容的翻译能力，特别是">
<meta property="og:type" content="article">
<meta property="og:title" content="cs.CL - 2023-09-10">
<meta property="og:url" content="https://nullscc.github.io/2023/09/10/cs.CL_2023_09_10/index.html">
<meta property="og:site_name" content="Fun Paper">
<meta property="og:description" content="The Effect of Alignment Objectives on Code-Switching Translation paper_url: http:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2309.05044 repo_url: None paper_authors: Mohamed Anwar for: 这个论文主要是为了提高机器翻译模型对Code-switching内容的翻译能力，特别是">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-09-10T11:00:00.000Z">
<meta property="article:modified_time" content="2023-09-23T08:57:19.161Z">
<meta property="article:author" content="nullscc">
<meta name="twitter:card" content="summary">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    <link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
  

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <nav id="upper-nav" class="inner">
      <a id="main-nav-toggle" class="nav-icon"></a>
      <div class="sub-nav">
        
        
          <a id="nav-github" class="nav-icon" target="_blank" rel="noopener" href="https://github.com/nullscc"></a>
        
      </div>
    </nav>
    <div id="header-title">
      
        <h1 id="blog-title-wrap">
          <a href="/" id="blog-title">Fun Paper</a>
        </h1>
      
    </div>
    <div id="contenedor">
      <ul class="cube">
        <li class="cara">Paper</li>
        <li class="cara"></li>
        <li class="cara"></li>
        <li class="cara"></li>
        <li class="cara"></li>
        <li class="cara"></li>
      </ul>
    </div>
    <nav id="main-nav">
      
        <a class="main-nav-link" href="/">Home</a>
      
        <a class="main-nav-link" href="/archives">Archives</a>
      
    </nav>
  </div>
</header>

    <div class="outer">
      <section id="main"><article id="post-cs.CL_2023_09_10" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2023/09/10/cs.CL_2023_09_10/" class="article-date">
  <time datetime="2023-09-10T11:00:00.000Z" itemprop="datePublished">2023-09-10</time>
</h3>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/cs-CL/">cs.CL</a>
  </div>

  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      cs.CL - 2023-09-10
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <h2 id="The-Effect-of-Alignment-Objectives-on-Code-Switching-Translation"><a href="#The-Effect-of-Alignment-Objectives-on-Code-Switching-Translation" class="headerlink" title="The Effect of Alignment Objectives on Code-Switching Translation"></a>The Effect of Alignment Objectives on Code-Switching Translation</h2><ul>
<li>paper_url: <a target="_blank" rel="noopener" href="http://arxiv.org/abs/2309.05044">http://arxiv.org/abs/2309.05044</a></li>
<li>repo_url: None</li>
<li>paper_authors: Mohamed Anwar</li>
<li>for: 这个论文主要是为了提高机器翻译模型对Code-switching内容的翻译能力，特别是随着社交媒体和用户生成内容的兴起。</li>
<li>methods: 该论文提出了一种训练单个机器翻译模型，可以将一种语言中的单 sentence翻译成另一种语言，同时也可以翻译code-switched sentence。这个模型可以看作是人类的双语模型。为了更好地利用平行数据，我们生成了Synthetic Code-switched (CSW) 数据，并在编码器上添加了对齐损失，以将语言表示 align across languages。</li>
<li>results: 使用WMT14英语-法语（En-Fr）数据集，训练过程中的模型在处理code-switched翻译时强制性超过了批量基eline，同时保持了非code-switched（单语言）数据的质量。<details>
<summary>Abstract</summary>
One of the things that need to change when it comes to machine translation is the models' ability to translate code-switching content, especially with the rise of social media and user-generated content. In this paper, we are proposing a way of training a single machine translation model that is able to translate monolingual sentences from one language to another, along with translating code-switched sentences to either language. This model can be considered a bilingual model in the human sense. For better use of parallel data, we generated synthetic code-switched (CSW) data along with an alignment loss on the encoder to align representations across languages. Using the WMT14 English-French (En-Fr) dataset, the trained model strongly outperforms bidirectional baselines on code-switched translation while maintaining quality for non-code-switched (monolingual) data.
</details>
<details>
<summary>摘要</summary>
一些需要改变的事情在机器翻译方面是模型对混合语言内容的翻译能力，尤其是随着社交媒体和用户生成内容的兴起。在这篇论文中，我们提出了一种训练单个机器翻译模型，可以将一种语言中的单语句翻译成另一种语言，同时也可以翻译混合语言句子到任一种语言。这个模型可以被视为人类中的双语模型。为了更好地利用平行数据，我们生成了人工合成的混合语言数据，并在编码器中添加了对逻辑的损失，以确保语言之间的表示相互对应。使用WMT14英语-法语（En-Fr）数据集，我们训练的模型在混合语言翻译中强制超越了irectional基eline，同时保持了非混合语言数据的质量。
</details></li>
</ul>
<hr>
<h2 id="Chat2Brain-A-Method-for-Mapping-Open-Ended-Semantic-Queries-to-Brain-Activation-Maps"><a href="#Chat2Brain-A-Method-for-Mapping-Open-Ended-Semantic-Queries-to-Brain-Activation-Maps" class="headerlink" title="Chat2Brain: A Method for Mapping Open-Ended Semantic Queries to Brain Activation Maps"></a>Chat2Brain: A Method for Mapping Open-Ended Semantic Queries to Brain Activation Maps</h2><ul>
<li>paper_url: <a target="_blank" rel="noopener" href="http://arxiv.org/abs/2309.05021">http://arxiv.org/abs/2309.05021</a></li>
<li>repo_url: None</li>
<li>paper_authors: Yaonai Wei, Tuo Zhang, Han Zhang, Tianyang Zhong, Lin Zhao, Zhengliang Liu, Chong Ma, Songyao Zhang, Muheng Shang, Lei Du, Xiao Li, Tianming Liu, Junwei Han</li>
<li>for: 本研究旨在提高meta-analysis中文本Query的准确性，使用大型自然语言模型(LLMs)来解决现有的问题，如semantic redundancy和ambiguity。</li>
<li>methods: 本研究使用了一种称为Chat2Brain的方法，它将基本的文本-2-图模型(Text2Brain)与LLMs相结合，以将开放式SemanticQuery映射到大脑活动图像中。</li>
<li>results: 研究表明，Chat2Brain可以将文本Query转化为具有生物学可能性的大脑活动图像，并且在数据缺乏和复杂的查询环境中表现出了优于Text2Brain模型。<details>
<summary>Abstract</summary>
Over decades, neuroscience has accumulated a wealth of research results in the text modality that can be used to explore cognitive processes. Meta-analysis is a typical method that successfully establishes a link from text queries to brain activation maps using these research results, but it still relies on an ideal query environment. In practical applications, text queries used for meta-analyses may encounter issues such as semantic redundancy and ambiguity, resulting in an inaccurate mapping to brain images. On the other hand, large language models (LLMs) like ChatGPT have shown great potential in tasks such as context understanding and reasoning, displaying a high degree of consistency with human natural language. Hence, LLMs could improve the connection between text modality and neuroscience, resolving existing challenges of meta-analyses. In this study, we propose a method called Chat2Brain that combines LLMs to basic text-2-image model, known as Text2Brain, to map open-ended semantic queries to brain activation maps in data-scarce and complex query environments. By utilizing the understanding and reasoning capabilities of LLMs, the performance of the mapping model is optimized by transferring text queries to semantic queries. We demonstrate that Chat2Brain can synthesize anatomically plausible neural activation patterns for more complex tasks of text queries.
</details>
<details>
<summary>摘要</summary>
（注：以下是简化中文版本）多年来，神经科学在文本模式中积累了大量的研究成果，可以用来探索认知过程。meta分析是一种常见的方法，可以将文本查询映射到大脑活动图表，但是它仍然依赖于理想的查询环境。在实际应用中，用于meta分析的文本查询可能会遇到 semantics redundancy和ambiguity问题，导致不准确地映射到大脑图像。然而，大型自然语言模型（LLMs）如ChatGPT显示出了在上下文理解和思维任务中的极高潜力，这与人类自然语言的一致度很高。因此，LLMs可以改善文本模式和神经科学之间的连接，解决现有的meta分析挑战。在这项研究中，我们提议一种名为Chat2Brain的方法，将LLMs与基本的文本-2-图模型（Text2Brain）结合，以将开放式semantic查询映射到大脑活动图表中。通过利用LLMs的理解和思维能力，我们可以优化映射模型的性能，将文本查询转化为semantic查询。我们示例ify that Chat2Brain可以生成符合生物学原理的大脑活动 Patterns for more complex tasks of text queries.
</details></li>
</ul>
<hr>
<h2 id="Machine-Translation-Models-Stand-Strong-in-the-Face-of-Adversarial-Attacks"><a href="#Machine-Translation-Models-Stand-Strong-in-the-Face-of-Adversarial-Attacks" class="headerlink" title="Machine Translation Models Stand Strong in the Face of Adversarial Attacks"></a>Machine Translation Models Stand Strong in the Face of Adversarial Attacks</h2><ul>
<li>paper_url: <a target="_blank" rel="noopener" href="http://arxiv.org/abs/2309.06527">http://arxiv.org/abs/2309.06527</a></li>
<li>repo_url: None</li>
<li>paper_authors: Pavel Burnyshev, Elizaveta Kostenok, Alexey Zaytsev</li>
<li>for: 本研究探讨了深度学习模型面临攻击时的漏洞，具体来说是对序列至序列（seq2seq）模型的机器翻译模型进行攻击。</li>
<li>methods: 我们引入了基本文本扰动规则和更高级别的策略，如梯度基于攻击，利用不可导的翻译度量的拟合来进行攻击。</li>
<li>results: 我们的研究表明，机器翻译模型对已知最佳攻击方法 Displayed robustness，输入扰动与输出扰动直接相关。但是，在弱者中，我们的攻击表现最好，与其他攻击相比，具有最高相对性。另一强 candidate是基于个体字符混合的攻击。<details>
<summary>Abstract</summary>
Adversarial attacks expose vulnerabilities of deep learning models by introducing minor perturbations to the input, which lead to substantial alterations in the output. Our research focuses on the impact of such adversarial attacks on sequence-to-sequence (seq2seq) models, specifically machine translation models. We introduce algorithms that incorporate basic text perturbation heuristics and more advanced strategies, such as the gradient-based attack, which utilizes a differentiable approximation of the inherently non-differentiable translation metric. Through our investigation, we provide evidence that machine translation models display robustness displayed robustness against best performed known adversarial attacks, as the degree of perturbation in the output is directly proportional to the perturbation in the input. However, among underdogs, our attacks outperform alternatives, providing the best relative performance. Another strong candidate is an attack based on mixing of individual characters.
</details>
<details>
<summary>摘要</summary>
深度学习模型的敌对攻击暴露了它们的漏洞，通过对输入添加微小的修改，导致输出受到重大的变化。我们的研究关注于seq2seq模型，具体来说是机器翻译模型，对于这类模型的敌对攻击。我们提出了基于文本修饰规则和更高级的策略，如基于梯度的攻击，利用可微的翻译评价函数来近似非微分的翻译评价函数。我们的调查发现，机器翻译模型对已知最佳敌对攻击表现出了强健性，输入修饰程度与输出修饰程度直接相关。然而，在弱者中，我们的攻击表现最佳，提供了最好的相对性。另一个强 канди达是基于个体字符混合的攻击。
</details></li>
</ul>
<hr>
<h2 id="Mitigating-Word-Bias-in-Zero-shot-Prompt-based-Classifiers"><a href="#Mitigating-Word-Bias-in-Zero-shot-Prompt-based-Classifiers" class="headerlink" title="Mitigating Word Bias in Zero-shot Prompt-based Classifiers"></a>Mitigating Word Bias in Zero-shot Prompt-based Classifiers</h2><ul>
<li>paper_url: <a target="_blank" rel="noopener" href="http://arxiv.org/abs/2309.04992">http://arxiv.org/abs/2309.04992</a></li>
<li>repo_url: None</li>
<li>paper_authors: Adian Liusie, Potsawee Manakul, Mark J. F. Gales</li>
<li>for: 提高 prompt-based 分类器的性能，解决 word biases 问题</li>
<li>methods: 使用 unsupervised 方法，对类别的预测概率进行重新权重，并与语言模型的词权相连</li>
<li>results: 实现了大幅提高 prompt 设置的性能，与 oracle Upper bound 性能呈现强相关，并可以在 zero-resource 环境下设置阈值<details>
<summary>Abstract</summary>
Prompt-based classifiers are an attractive approach for zero-shot classification. However, the precise choice of the prompt template and label words can largely influence performance, with semantically equivalent settings often showing notable performance difference. This discrepancy can be partly attributed to word biases, where the classifier may be biased towards classes. To address this problem, it is possible to optimise classification thresholds on a labelled data set, however, this mitigates some of the advantages of prompt-based classifiers. This paper instead approaches this problem by examining the expected marginal probabilities of the classes. Here, probabilities are reweighted to have a uniform prior over classes, in an unsupervised fashion. Further, we draw a theoretical connection between the class priors and the language models' word prior, and offer the ability to set a threshold in a zero-resource fashion. We show that matching class priors correlates strongly with the oracle upper bound performance and demonstrate large consistent performance gains for prompt settings over a range of NLP tasks.
</details>
<details>
<summary>摘要</summary>
This paper proposes a different approach: reweighting probabilities to have a uniform prior over classes in an unsupervised fashion. The expected marginal probabilities of the classes are examined, and a threshold can be set in a zero-resource fashion. The class priors are found to be closely related to the language models' word prior, and matching class priors can achieve strong performance gains for prompt settings across a range of NLP tasks.
</details></li>
</ul>
<hr>
<h2 id="Retrieval-Augmented-Meta-Learning-for-Low-Resource-Text-Classification"><a href="#Retrieval-Augmented-Meta-Learning-for-Low-Resource-Text-Classification" class="headerlink" title="Retrieval-Augmented Meta Learning for Low-Resource Text Classification"></a>Retrieval-Augmented Meta Learning for Low-Resource Text Classification</h2><ul>
<li>paper_url: <a target="_blank" rel="noopener" href="http://arxiv.org/abs/2309.04979">http://arxiv.org/abs/2309.04979</a></li>
<li>repo_url: <a target="_blank" rel="noopener" href="https://github.com/Carolmelon/RAML">https://github.com/Carolmelon/RAML</a></li>
<li>paper_authors: Rongsheng Li, Yangning Li, Yinghui Li, Chaiyut Luoyiching, Hai-Tao Zheng, Nannan Zhou, Hanjing Su</li>
<li>for: 优化低资源文本分类任务的表现，通过从源类任务中传递知识来预测目标类。</li>
<li>methods: 使用参数化神经网络进行推理，并从外部词库中检索非参数化知识来增强推理表现。</li>
<li>results: 在低资源文本分类任务中显著超过当前最佳状态的表现。<details>
<summary>Abstract</summary>
Meta learning have achieved promising performance in low-resource text classification which aims to identify target classes with knowledge transferred from source classes with sets of small tasks named episodes. However, due to the limited training data in the meta-learning scenario and the inherent properties of parameterized neural networks, poor generalization performance has become a pressing problem that needs to be addressed. To deal with this issue, we propose a meta-learning based method called Retrieval-Augmented Meta Learning(RAML). It not only uses parameterization for inference but also retrieves non-parametric knowledge from an external corpus to make inferences, which greatly alleviates the problem of poor generalization performance caused by the lack of diverse training data in meta-learning. This method differs from previous models that solely rely on parameters, as it explicitly emphasizes the importance of non-parametric knowledge, aiming to strike a balance between parameterized neural networks and non-parametric knowledge. The model is required to determine which knowledge to access and utilize during inference. Additionally, our multi-view passages fusion network module can effectively and efficiently integrate the retrieved information into low-resource classification task. The extensive experiments demonstrate that RAML significantly outperforms current SOTA low-resource text classification models.
</details>
<details>
<summary>摘要</summary>
Meta 学习已经实现了低资源文本分类中的出色表现，通过从源类中 transferred 知识来标识目标类。然而，由于 meta-learning enario 中的培育数据有限和参数化神经网络的内在性质，低泛化性表现成为一个需要解决的问题。为解决这个问题，我们提出了 Retrieval-Augmented Meta Learning（RAML）方法。它不仅使用参数进行推理，而且从外部资源中检索非参数化知识，以便在推理时使用，这有效地解决了由于缺乏多样化培育数据而导致的低泛化性问题。与之前的模型不同，RAML 不仅仅仅靠参数来进行推理，而是强调非参数化知识的重要性，以达到参数化神经网络和非参数化知识之间的平衡。模型需要在推理时决定哪些知识要访问和利用。此外，我们的多视图通道融合网络模块可以高效地和有效地将检索到的信息集成到低资源分类任务中。广泛的实验表明，RAML 可以明显超过当前最佳的低资源文本分类模型。
</details></li>
</ul>
<hr>
<h2 id="Prompt-Learning-With-Knowledge-Memorizing-Prototypes-For-Generalized-Few-Shot-Intent-Detection"><a href="#Prompt-Learning-With-Knowledge-Memorizing-Prototypes-For-Generalized-Few-Shot-Intent-Detection" class="headerlink" title="Prompt Learning With Knowledge Memorizing Prototypes For Generalized Few-Shot Intent Detection"></a>Prompt Learning With Knowledge Memorizing Prototypes For Generalized Few-Shot Intent Detection</h2><ul>
<li>paper_url: <a target="_blank" rel="noopener" href="http://arxiv.org/abs/2309.04971">http://arxiv.org/abs/2309.04971</a></li>
<li>repo_url: None</li>
<li>paper_authors: Chaiyut Luoyiching, Yangning Li, Yinghui Li, Rongsheng Li, Hai-Tao Zheng, Nannan Zhou, Hanjing Su</li>
<li>for:  solves the challenging problem of generalized few-shot intent detection (GFSID) by converting the task into the class incremental learning paradigm.</li>
<li>methods:  proposes a two-stage learning framework that sequentially learns the knowledge of different intents in various periods via prompt learning, and uses prototypes to categorize both seen and novel intents.</li>
<li>results:  achieves promising performance on two widely used datasets through extensive experiments and detailed analyses.Here’s the full summary in Simplified Chinese:</li>
<li>for: 通过将GFSID任务转换为类增量学习 paradigm，解决了Generalized Few-Shot Intent Detection (GFSID) 的挑战性问题。</li>
<li>methods: 提议了一个两阶段学习框架，通过提示学习顺序地学习不同意图的知识，并使用prototype来分类seen和novel意图。</li>
<li>results: 通过广泛的实验和详细的分析，在两个广泛使用的数据集上达到了可观的表现。<details>
<summary>Abstract</summary>
Generalized Few-Shot Intent Detection (GFSID) is challenging and realistic because it needs to categorize both seen and novel intents simultaneously. Previous GFSID methods rely on the episodic learning paradigm, which makes it hard to extend to a generalized setup as they do not explicitly learn the classification of seen categories and the knowledge of seen intents. To address the dilemma, we propose to convert the GFSID task into the class incremental learning paradigm. Specifically, we propose a two-stage learning framework, which sequentially learns the knowledge of different intents in various periods via prompt learning. And then we exploit prototypes for categorizing both seen and novel intents. Furthermore, to achieve the transfer knowledge of intents in different stages, for different scenarios we design two knowledge preservation methods which close to realistic applications. Extensive experiments and detailed analyses on two widely used datasets show that our framework based on the class incremental learning paradigm achieves promising performance.
</details>
<details>
<summary>摘要</summary>
通用几招意图检测（GFSID）是一个具有挑战性和实用性的任务，因为它需要同时分类已知和新的意图。先前的GFSID方法基于 episodic learning 模式，这使得它们不能直接应用到通用化设置中。为解决这个困境，我们提议将 GFSID 任务转化为类增量学习模式。具体来说，我们提议一个两阶段学习框架，先后学习不同时期的意图知识via prompt learning。然后，我们利用示例来分类已知和新的意图。此外，为了保持意图在不同阶段的传递知识，我们设计了两种知识保持方法，它们更加适合实际应用。我们在两个广泛使用的数据集上进行了详细的实验和分析，得到了我们基于类增量学习模式的框架的优秀表现。
</details></li>
</ul>
<hr>
<h2 id="What’s-Hard-in-English-RST-Parsing-Predictive-Models-for-Error-Analysis"><a href="#What’s-Hard-in-English-RST-Parsing-Predictive-Models-for-Error-Analysis" class="headerlink" title="What’s Hard in English RST Parsing? Predictive Models for Error Analysis"></a>What’s Hard in English RST Parsing? Predictive Models for Error Analysis</h2><ul>
<li>paper_url: <a target="_blank" rel="noopener" href="http://arxiv.org/abs/2309.04940">http://arxiv.org/abs/2309.04940</a></li>
<li>repo_url: None</li>
<li>paper_authors: Yang Janet Liu, Tatsuya Aoyama, Amir Zeldes</li>
<li>for: 本研究旨在探讨逻辑结构理论下的层次话语分析仍然存在挑战，以及这些挑战的原因是如何。</li>
<li>methods: 本文使用了一些过去研究中的难点，包括半显式关系、远程关系、缺失词汇等因素，以及两个英文测试集，其中一个包含正确的金标RST关系，另一个包含干扰关系。</li>
<li>results: 我们的结果显示，与浅度话语分析一样，显式&#x2F;隐式之分在层次话语分析中也发挥了作用，但是远程依赖关系是主要的挑战，而词汇重叠的问题较少。我们的最终模型可以在76.3%的精度上预测错误的位置，Bottom-upParser 和 Top-downParser 都是如此。<details>
<summary>Abstract</summary>
Despite recent advances in Natural Language Processing (NLP), hierarchical discourse parsing in the framework of Rhetorical Structure Theory remains challenging, and our understanding of the reasons for this are as yet limited. In this paper, we examine and model some of the factors associated with parsing difficulties in previous work: the existence of implicit discourse relations, challenges in identifying long-distance relations, out-of-vocabulary items, and more. In order to assess the relative importance of these variables, we also release two annotated English test-sets with explicit correct and distracting discourse markers associated with gold standard RST relations. Our results show that as in shallow discourse parsing, the explicit/implicit distinction plays a role, but that long-distance dependencies are the main challenge, while lack of lexical overlap is less of a problem, at least for in-domain parsing. Our final model is able to predict where errors will occur with an accuracy of 76.3% for the bottom-up parser and 76.6% for the top-down parser.
</details>
<details>
<summary>摘要</summary>
尽管最近的自然语言处理（NLP）技术已经取得了 significiant advances，但在 rhethorical structure theory（RST）框架下的层次演化分析仍然是一个挑战，我们对这些挑战的理解仍然有限。在这篇论文中，我们研究了过去的 parsing 困难的一些因素，包括隐式 discourse relations 的存在、远程关系的挑战、out-of-vocabulary items 和更多的因素。为了评估这些变量的相对重要性，我们还发布了两个英文测试集，其中包含了可见的正确和干扰 discourse markers，与黄金标准 RST 关系相关。我们的结果表明，与浅层演化 parsing 类似，显式/隐式之分发挥了作用，但长距离依赖关系是主要挑战，而词汇重叠的不足则是一个较小的问题，至少是在预测 parsing 中。我们的最终模型能够预测错误的发生位置的准确率为 76.3%（底层parser）和 76.6%（顶层parser）。
</details></li>
</ul>
<hr>
<h2 id="Unsupervised-Chunking-with-Hierarchical-RNN"><a href="#Unsupervised-Chunking-with-Hierarchical-RNN" class="headerlink" title="Unsupervised Chunking with Hierarchical RNN"></a>Unsupervised Chunking with Hierarchical RNN</h2><ul>
<li>paper_url: <a target="_blank" rel="noopener" href="http://arxiv.org/abs/2309.04919">http://arxiv.org/abs/2309.04919</a></li>
<li>repo_url: <a target="_blank" rel="noopener" href="https://github.com/manga-uofa/uchrnn">https://github.com/manga-uofa/uchrnn</a></li>
<li>paper_authors: Zijun Wu, Anup Anand Deshmukh, Yongkang Wu, Jimmy Lin, Lili Mou</li>
<li>for: 这篇论文主要是为了探讨一种无监督的句子分析方法，即用Recurrent Neural Network (RNN)模型来自动从语言模式中提取句子结构。</li>
<li>methods: 这篇论文使用了一种两层层次RNN模型，即 Hierarchical Recurrent Neural Network (HRNN)，来模型单词到句子和句子到句子的组合。该方法包括了两个阶段的训练过程：首先预训练一个无监督分析器，然后使用下游NLP任务进行细化训练。</li>
<li>results: 实验结果表明，这种无监督 chunking 方法可以在 CoNLL-2000 数据集上提取句子结构，并且与现有的无监督方法相比，提高了一个phrase F1 分数的值。此外，在下游 NLP 任务的训练过程中，模型的性能进一步提高。有趣的是，我们发现在神经网络模型在下游任务训练过程中，句子结构的出现是暂时的。这种研究对无监督句子结构发现的进步做出了贡献，并开创了更多的语言理论研究的可能性。<details>
<summary>Abstract</summary>
In Natural Language Processing (NLP), predicting linguistic structures, such as parsing and chunking, has mostly relied on manual annotations of syntactic structures. This paper introduces an unsupervised approach to chunking, a syntactic task that involves grouping words in a non-hierarchical manner. We present a two-layer Hierarchical Recurrent Neural Network (HRNN) designed to model word-to-chunk and chunk-to-sentence compositions. Our approach involves a two-stage training process: pretraining with an unsupervised parser and finetuning on downstream NLP tasks. Experiments on the CoNLL-2000 dataset reveal a notable improvement over existing unsupervised methods, enhancing phrase F1 score by up to 6 percentage points. Further, finetuning with downstream tasks results in an additional performance improvement. Interestingly, we observe that the emergence of the chunking structure is transient during the neural model's downstream-task training. This study contributes to the advancement of unsupervised syntactic structure discovery and opens avenues for further research in linguistic theory.
</details>
<details>
<summary>摘要</summary>
在自然语言处理（NLP）领域，预测语言结构，如分析和块分，旁通过手动标注语法结构来进行。这篇论文介绍了一种不需要监督的块分法，即将词语组合成非层次的方式。我们提出了一种两层层次逻辑神经网络（HRNN），用于模elling 词语到块和块到句子的组合。我们的方法包括两个阶段的训练过程：预训练与无监督分析器和下游 NLP 任务的训练。实验结果表明，我们的方法在 CoNLL-2000 数据集上具有明显的提升，提高了phrase F1分数 by up to 6个百分点。此外，在下游任务的训练中，再进行一次性的性能提升。另外，我们发现在神经网络模型在下游任务训练过程中，块分结构的出现是暂时的。这项研究对无监督语法结构发现的进步做出了贡献，并开启了更多的语言理论研究的可能性。
</details></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
        <a data-url="https://nullscc.github.io/2023/09/10/cs.CL_2023_09_10/" data-id="clojdabhi00ap5l88ac8483kw" class="article-share-link">Share</a>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/09/10/cs.AI_2023_09_10/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          cs.AI - 2023-09-10
        
      </div>
    </a>
  
  
    <a href="/2023/09/10/cs.LG_2023_09_10/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">cs.LG - 2023-09-10</div>
    </a>
  
</nav>

  
</article>


</section>
      
      <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title">Calendar</h3>
  <div id="calendar"></div>
</div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/cs-AI/">cs.AI</a><span class="category-list-count">123</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cs-CL/">cs.CL</a><span class="category-list-count">123</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cs-CV/">cs.CV</a><span class="category-list-count">123</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cs-LG/">cs.LG</a><span class="category-list-count">123</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cs-SD/">cs.SD</a><span class="category-list-count">116</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/eess-AS/">eess.AS</a><span class="category-list-count">56</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/eess-IV/">eess.IV</a><span class="category-list-count">113</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/eess-SP/">eess.SP</a><span class="category-list-count">63</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a><span class="archive-list-count">231</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a><span class="archive-list-count">212</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a><span class="archive-list-count">175</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a><span class="archive-list-count">208</span></li></ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 nullscc<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/sun11/hexo-theme-paperbox" target="_blank">Paperbox</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>

  

<!-- totop start -->
<div id="totop">
	<a title="To Top"></a>
</div>
<!-- totop end -->

<!-- swiftype search start -->

<!-- swiftype search end -->



<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/lrsjng.jquery-qrcode/0.12.0/jquery.qrcode.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>



<!-- add calendar widget -->

  <script src="/js/calendar.js"></script>
  <script src="/js/languages.js"></script>
  <script type="text/javascript">
    $(function() {
    
      $('#calendar').aCalendar('en', $.extend('{"months":["January","February","March","April","May","June","July","August","September","October","November","December"],"dayOfWeekShort":["S","M","T","W","T","F","S"],"dayOfWeek":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"]}', {single:'true', root:'calendar/'}));
    
    });
  </script>



<script src="/js/script.js"></script>


</div>
</body>
</html>
